{"source_files":[{"coverage":[null,null,null],"name":"lib/media_server_web/views/user_session_view.ex","source":"defmodule MediaServerWeb.UserSessionView do\n  use MediaServerWeb, :view\nend"},{"coverage":[null,null,null,null,1,1,null,null,null,null,null,1,null,null],"name":"lib/media_server_web/live/movies_live/index.ex","source":"defmodule MediaServerWeb.MoviesLive.Index do\n  use MediaServerWeb, :live_view\n\n  @impl true\n  def handle_params(params, _url, socket) do\n    {:noreply, apply_action(socket, socket.assigns.live_action, params)}\n  end\n\n  defp apply_action(socket, :index, _params) do\n    socket\n    |> assign(:page_title, :Movies)\n    |> assign(:decoded, MediaServerWeb.Repositories.Movies.get_all())\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null],"name":"lib/media_server_web/views/error_view.ex","source":"defmodule MediaServerWeb.ErrorView do\n  use MediaServerWeb, :view\n\n  # If you want to customize a particular status code\n  # for a certain format, you may uncomment below.\n  # def render(\"500.html\", _assigns) do\n  #   \"Internal Server Error\"\n  # end\n\n  # By default, Phoenix returns the status message from\n  # the template name. For example, \"404.html\" becomes\n  # \"Not Found\".\n  def template_not_found(template, _assigns) do\n    Phoenix.Controller.status_message_from_template(template)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,3,3,null,null,null],"name":"test/support/channel_case.ex","source":"defmodule MediaServerWeb.ChannelCase do\n  @moduledoc \"\"\"\n  This module defines the test case to be used by\n  channel tests.\n\n  Such tests rely on `Phoenix.ChannelTest` and also\n  import other functionality to make it easier\n  to build common data structures and query the data layer.\n\n  Finally, if the test case interacts with the database,\n  we enable the SQL sandbox, so changes done to the database\n  are reverted at the end of every test. If you are using\n  PostgreSQL, you can even run database tests asynchronously\n  by setting `use MediaServerWeb.ChannelCase, async: true`, although\n  this option is not recommended for other databases.\n  \"\"\"\n\n  use ExUnit.CaseTemplate\n\n  using do\n    quote do\n      # Import conveniences for testing with channels\n      import Phoenix.ChannelTest\n      import MediaServerWeb.ChannelCase\n\n      # The default endpoint for testing\n      @endpoint MediaServerWeb.Endpoint\n    end\n  end\n\n  setup tags do\n    pid = Ecto.Adapters.SQL.Sandbox.start_owner!(MediaServer.Repo, shared: not tags[:async])\n    on_exit(fn -> Ecto.Adapters.SQL.Sandbox.stop_owner(pid) end)\n    :ok\n  end\nend"},{"coverage":[null,null,null,null,null,0,0,0,null,null,null,null,0,null,null,null,0,0,null,null,null,null,null,null,0,0,null,null],"name":"lib/media_server_web/live/modal_component.ex","source":"defmodule MediaServerWeb.ModalComponent do\n  use MediaServerWeb, :live_component\n\n  @impl true\n  def render(assigns) do\n    ~H\"\"\"\n    <div\n      id={@id}\n      class=\"phx-modal\"\n      phx-capture-click=\"close\"\n      phx-window-keydown=\"close\"\n      phx-key=\"escape\"\n      phx-target={@myself}\n      phx-page-loading>\n\n      <div class=\"phx-modal-content\">\n        <%= live_patch raw(\"&times;\"), to: @return_to, class: \"phx-modal-close\" %>\n        <%= live_component @component, @opts %>\n      </div>\n    </div>\n    \"\"\"\n  end\n\n  @impl true\n  def handle_event(\"close\", _, socket) do\n    {:noreply, push_patch(socket, to: socket.assigns.return_to)}\n  end\nend"},{"coverage":[null,null,null,null,60,null,null,null,null,null,null,null,null,null,null,null,50,null,null],"name":"lib/media_server/integrations/radarr.ex","source":"defmodule MediaServer.Integrations.Radarr do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"radarrs\" do\n    field :api_key, :string\n    field :name, :string\n    field :url, :string\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(radarr, attrs) do\n    radarr\n    |> cast(attrs, [:name, :url, :api_key])\n    |> validate_required([:name, :url, :api_key])\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,6,null,null,null,null,null,null,null,null,6,null,null,null,14,null,null,null,null,null,14,null,null,14,null,14,null,14,null,14,null,null,null,14,null,null,14,null,14,null,null,null,null,0,null,null,0,null,0,null,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,14,null,null,null,null,null,null,null,null,14,14,null,14,null,null,null,null,null,null,8,null,null,null,null,null,null,null,null,8,null,null,null,14,null,null,null,null,null,14,null,null,14,null,14,14,null,14,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,14,null,null,null,null,null,null,null,null,14,14,null,null,null,null],"name":"test/support/fixtures/providers_fixtures.ex","source":"defmodule MediaServer.IntegrationsFixtures do\n  @moduledoc \"\"\"\n  This module defines test helpers for creating\n  entities via the `MediaServer.Integrations` context.\n  \"\"\"\n\n  @doc \"\"\"\n  Generate a sonarr.\n  \"\"\"\n  def sonarr_fixture(attrs \\\\ %{}) do\n    {:ok, sonarr} =\n      attrs\n      |> Enum.into(%{\n        api_key: \"some api_key\",\n        name: \"some name\",\n        url: \"some url\"\n      })\n      |> MediaServer.Integrations.create_sonarr()\n\n    sonarr\n  end\n\n  def add_series_root(provider) do\n    HTTPoison.post!(\"#{ provider.url }/rootFolder?apikey=#{ provider.api_key }\", Jason.encode!(%{\n      path: \"/shows\"\n    }))\n  end\n\n  def add_series(provider) do\n    case HTTPoison.get(\"#{ provider.url }/series?apikey=#{ provider.api_key }\") do\n\n      {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->\n        decoded = Jason.decode!(body)\n\n        if length(decoded) !== 0 do\n\n          series = Enum.at(decoded, 0)\n\n          case HTTPoison.get(\"#{ provider.url }/episode?seriesId=#{ series[\"id\"] }&apikey=#{ provider.api_key }\") do\n\n            {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->\n\n              episode = Enum.filter(Jason.decode!(body), fn x -> x[\"hasFile\"] end)\n                                |> Enum.at(0)\n\n              episode_id = episode[\"id\"]\n\n              series_id = series[\"id\"]\n\n              { series_id, episode_id }\n          end\n        else\n          case HTTPoison.post(\"#{ provider.url }/series/import?apikey=#{ provider.api_key }\", '[{\"title\":\"The Beverly Hillbillies\",\"sortTitle\":\"beverly hillbillies\",\"status\":\"ended\",\"ended\":true,\"overview\":\"The Beverly Hillbillies is among the most successful comedies in American television history, and remains one of the few sitcoms to involve serial plotlines. It centered around Jed Clampett, a simple backwoods mountaineer who becomes a millionaire when oil is discovered on his property and then moves his family to Beverly Hills. The fish-out-of-water farce ran for nine seasons.\",\"network\":\"CBS\",\"airTime\":\"19:30\",\"images\":[{\"coverType\":\"banner\",\"url\":\"/MediaCoverProxy/033b5d71e4e3939297f68892c846bee82de9aa63a6e187358efa8f06cbf70dd3/71471-g2.jpg\",\"remoteUrl\":\"https://artworks.thetvdb.com/banners/graphical/71471-g2.jpg\"},{\"coverType\":\"poster\",\"url\":\"/MediaCoverProxy/27f38d8b79d2d56f2760b78530ad6581da35244546c3c0480ed957c6f231197d/71471-7.jpg\",\"remoteUrl\":\"https://artworks.thetvdb.com/banners/posters/71471-7.jpg\"},{\"coverType\":\"fanart\",\"url\":\"/MediaCoverProxy/56492f722b55c21f01920d161f7a682f9aab6f83fdee7b7acd3783f9fe6a3cdd/71471-1.jpg\",\"remoteUrl\":\"https://artworks.thetvdb.com/banners/fanart/original/71471-1.jpg\"}],\"remotePoster\":\"https://artworks.thetvdb.com/banners/posters/71471-7.jpg\",\"seasons\":[{\"seasonNumber\":0,\"monitored\":false},{\"seasonNumber\":1,\"monitored\":true},{\"seasonNumber\":2,\"monitored\":true},{\"seasonNumber\":3,\"monitored\":true},{\"seasonNumber\":4,\"monitored\":true},{\"seasonNumber\":5,\"monitored\":true},{\"seasonNumber\":6,\"monitored\":true},{\"seasonNumber\":7,\"monitored\":true},{\"seasonNumber\":8,\"monitored\":true},{\"seasonNumber\":9,\"monitored\":true}],\"year\":1962,\"qualityProfileId\":1,\"languageProfileId\":1,\"seasonFolder\":true,\"monitored\":true,\"useSceneNumbering\":false,\"runtime\":25,\"tvdbId\":71471,\"tvRageId\":5615,\"tvMazeId\":2139,\"firstAired\":\"1962-09-26T00:00:00Z\",\"seriesType\":\"standard\",\"cleanTitle\":\"thebeverlyhillbillies\",\"imdbId\":\"tt0055662\",\"titleSlug\":\"the-beverly-hillbillies\",\"folder\":\"The Beverly Hillbillies\",\"certification\":\"TV-G\",\"genres\":[\"Comedy\"],\"added\":\"0001-01-01T00:00:00Z\",\"ratings\":{\"votes\":333,\"value\":9.3},\"statistics\":{\"seasonCount\":9,\"episodeFileCount\":0,\"episodeCount\":0,\"totalEpisodeCount\":0,\"sizeOnDisk\":0,\"percentOfEpisodes\":0},\"addOptions\":{\"monitor\":\"none\",\"searchForMissingEpisodes\":false,\"searchForCutoffUnmetEpisodes\":false},\"path\":\"/shows/The Beverly Hillbillies\"}]') do\n\n            {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->\n              Jason.decode!(body)\n\n              case HTTPoison.get(\"#{ provider.url }/episode?seriesId=#{ body[\"id\"] }&apikey=#{ provider.api_key }\") do\n\n                {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->\n\n                  episode = Enum.filter(Jason.decode!(body), fn x -> x[\"hasFile\"] end)\n                            |> Enum.at(0)\n\n                  episode_id = episode[\"id\"]\n\n                  series_id = body[\"id\"]\n\n                  { series_id, episode_id }\n              end\n          end\n        end\n    end\n  end\n\n  @doc \"\"\"\n  Generate a real sonarr.\n  \"\"\"\n  def real_sonarr_fixture(attrs \\\\ %{}) do\n    {:ok, sonarr} =\n      attrs\n      |> Enum.into(%{\n        api_key: \"1accda4476394bfcaddefe8c4fd77d4a\",\n        name: \"Series\",\n        url: \"sonarr:8989/api/v3\"\n      })\n      |> MediaServer.Integrations.create_sonarr()\n\n    add_series_root(sonarr)\n    { series_id, episode_id } = add_series(sonarr)\n\n    {sonarr, series_id, episode_id}\n  end\n\n  @doc \"\"\"\n  Generate a radarr.\n  \"\"\"\n  def radarr_fixture(attrs \\\\ %{}) do\n    {:ok, radarr} =\n      attrs\n      |> Enum.into(%{\n        api_key: \"some api_key\",\n        name: \"some name\",\n        url: \"some url\"\n      })\n      |> MediaServer.Integrations.create_radarr()\n\n    radarr\n  end\n\n  def add_movie_root(provider) do\n    HTTPoison.post!(\"#{ provider.url }/rootFolder?apiKey=#{ provider.api_key }\", Jason.encode!(%{\n      path: \"/movies\"\n    }))\n  end\n\n  def add_movie(provider) do\n    case HTTPoison.get(\"#{ provider.url }/movie?apiKey=#{ provider.api_key }\") do\n\n      {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->\n        decoded = Jason.decode!(body)\n\n        if length(decoded) do\n          movie = Enum.at(decoded, 0)\n\n          movie[\"id\"]\n\n        else\n          case HTTPoison.post(\"#{ provider.url }/movie/import?apiKey=#{ provider.api_key }\", '[{\"title\":\"Popeye the Sailor Meets Sindbad the Sailor\",\"originalTitle\":\"Popeye the Sailor Meets Sindbad the Sailor\",\"alternateTitles\":[{\"sourceType\":\"tmdb\",\"movieId\":0,\"title\":\"Popeye el marino contra Sindbad el marino\",\"sourceId\":0,\"votes\":0,\"voteCount\":0,\"language\":{\"id\":3,\"name\":\"Spanish\"}},{\"sourceType\":\"tmdb\",\"movieId\":0,\"title\":\"POPEYE The Sailor-- Meets SINDBAD The Sailor\",\"sourceId\":0,\"votes\":0,\"voteCount\":0,\"language\":{\"id\":1,\"name\":\"English\"}}],\"secondaryYearSourceId\":0,\"sortTitle\":\"popeye sailor meets sindbad sailor\",\"sizeOnDisk\":0,\"status\":\"released\",\"overview\":\"Two sailors Sindbad and Popeye decide to test themselves in order to prove their supremacy. Popeye is then presented with a series of daunting tasks by Sindbad.\",\"inCinemas\":\"1936-11-27T00:00:00Z\",\"images\":[{\"coverType\":\"poster\",\"url\":\"/MediaCoverProxy/1001a443b0dca7fc39ff726fd413b13ab274d9cd6b871cc8d7ed25f025c9263b/Ae4r3014zCLSbaL9PiiFm9QGWXS.jpg\",\"remoteUrl\":\"https://image.tmdb.org/t/p/original/Ae4r3014zCLSbaL9PiiFm9QGWXS.jpg\"},{\"coverType\":\"fanart\",\"url\":\"/MediaCoverProxy/4e93439432826373ba0b2475bb9e646d69ffad0ab32867637fdef2c24fa637dd/v72aGYqPcX5kLD1AVzsTXoxfS4d.jpg\",\"remoteUrl\":\"https://image.tmdb.org/t/p/original/v72aGYqPcX5kLD1AVzsTXoxfS4d.jpg\"}],\"website\":\"\",\"remotePoster\":\"https://image.tmdb.org/t/p/original/Ae4r3014zCLSbaL9PiiFm9QGWXS.jpg\",\"year\":1936,\"hasFile\":false,\"youTubeTrailerId\":\"\",\"studio\":\"Fleischer Studios\",\"qualityProfileId\":1,\"monitored\":false,\"minimumAvailability\":\"announced\",\"isAvailable\":true,\"folderName\":\"\",\"runtime\":16,\"cleanTitle\":\"popeyesailormeetssindbadsailor\",\"imdbId\":\"tt0028119\",\"tmdbId\":67713,\"titleSlug\":\"67713\",\"folder\":\"Popeye the Sailor Meets Sindbad the Sailor (1936)\",\"genres\":[\"Animation\",\"Adventure\",\"Comedy\"],\"added\":\"0001-01-01T00:00:00Z\",\"ratings\":{\"votes\":67,\"value\":6.4},\"addOptions\":{\"searchForMovie\":false},\"path\":\"/movies/Popeye the Sailor Meets Sindbad the Sailor(1936)\"}]') do\n\n            {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->\n              Jason.decode!(body)\n\n              body[\"id\"]\n          end\n        end\n    end\n  end\n\n  @doc \"\"\"\n  Generate real radarr.\n  \"\"\"\n  def real_radarr_fixture(attrs \\\\ %{}) do\n    {:ok, radarr} =\n      attrs\n      |> Enum.into(%{\n        api_key: \"d031e8c9b9df4b2fab311d1c3b3fa2c5\",\n        name: \"Movies\",\n        url: \"radarr:7878/api/v3\"\n      })\n      |> MediaServer.Integrations.create_radarr()\n\n    add_movie_root(radarr)\n    movie_id = add_movie(radarr)\n\n    {radarr, movie_id}\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null],"name":"lib/media_server_web/channels/presence.ex","source":"defmodule MediaServerWeb.Presence do\n  @moduledoc \"\"\"\n  Provides presence tracking to channels and processes.\n\n  See the [`Phoenix.Presence`](http://hexdocs.pm/phoenix/Phoenix.Presence.html)\n  docs for more details.\n  \"\"\"\n  use Phoenix.Presence, otp_app: :media_server,\n                        pubsub_server: MediaServer.PubSub\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null],"name":"lib/media_server_web.ex","source":"defmodule MediaServerWeb do\n  @moduledoc \"\"\"\n  The entrypoint for defining your web interface, such\n  as controllers, views, channels and so on.\n\n  This can be used in your application as:\n\n      use MediaServerWeb, :controller\n      use MediaServerWeb, :view\n\n  The definitions below will be executed for every view,\n  controller, etc, so keep them short and clean, focused\n  on imports, uses and aliases.\n\n  Do NOT define functions inside the quoted expressions\n  below. Instead, define any helper function in modules\n  and import those modules here.\n  \"\"\"\n\n  def controller do\n    quote do\n      use Phoenix.Controller, namespace: MediaServerWeb\n\n      import Plug.Conn\n      import MediaServerWeb.Gettext\n      alias MediaServerWeb.Router.Helpers, as: Routes\n    end\n  end\n\n  def view do\n    quote do\n      use Phoenix.View,\n        root: \"lib/media_server_web/templates\",\n        namespace: MediaServerWeb\n\n      # Import convenience functions from controllers\n      import Phoenix.Controller,\n        only: [get_flash: 1, get_flash: 2, view_module: 1, view_template: 1]\n\n      # Include shared imports and aliases for views\n      unquote(view_helpers())\n    end\n  end\n\n  def live_view do\n    quote do\n      use Phoenix.LiveView,\n        layout: {MediaServerWeb.LayoutView, \"live.html\"}\n\n      unquote(view_helpers())\n    end\n  end\n\n  def live_component do\n    quote do\n      use Phoenix.LiveComponent\n\n      unquote(view_helpers())\n    end\n  end\n\n  def router do\n    quote do\n      use Phoenix.Router\n\n      import Plug.Conn\n      import Phoenix.Controller\n      import Phoenix.LiveView.Router\n    end\n  end\n\n  def channel do\n    quote do\n      use Phoenix.Channel\n      import MediaServerWeb.Gettext\n    end\n  end\n\n  defp view_helpers do\n    quote do\n      # Use all HTML functionality (forms, tags, etc)\n      use Phoenix.HTML\n\n      # Import LiveView and .heex helpers (live_render, live_patch, <.form>, etc)\n      import Phoenix.LiveView.Helpers\n      import MediaServerWeb.LiveHelpers\n\n      # Import basic rendering functionality (render, render_layout, etc)\n      import Phoenix.View\n\n      import MediaServerWeb.ErrorHelpers\n      import MediaServerWeb.Gettext\n      alias MediaServerWeb.Router.Helpers, as: Routes\n    end\n  end\n\n  @doc \"\"\"\n  When used, dispatch to the appropriate controller/view/etc.\n  \"\"\"\n  defmacro __using__(which) when is_atom(which) do\n    apply(__MODULE__, which, [])\n  end\nend"},{"coverage":[null,null,null,null,200,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,108,null,null,null,null,null,null,null,null,116,null,null,null,null,null,127,null,null,null,null,null,null,null,null,null,119,null,null,null,119,119,null,119,null,null,null,null,88,null,31,null,null,null,null,null,null,null,null,null,null,null,null,8,6,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,11,null,null,null,null,null,19,null,null,null,null,null,null,2,2,null,null,null,null,null,null,null,null,null,null,37,null,null,null,1,null,null,null,null,null,null,null,11,9,null,2,null,null,null],"name":"lib/media_server/accounts/user.ex","source":"defmodule MediaServer.Accounts.User do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"users\" do\n    field :email, :string\n    field :name, :string\n    field :password, :string, virtual: true, redact: true\n    field :hashed_password, :string, redact: true\n    field :confirmed_at, :naive_datetime\n    field :is_admin, :boolean\n\n    timestamps()\n  end\n\n  @doc \"\"\"\n  A user changeset for registration.\n\n  It is important to validate the length of both email and password.\n  Otherwise databases may truncate the email without warnings, which\n  could lead to unpredictable or insecure behaviour. Long passwords may\n  also be very expensive to hash for certain algorithms.\n\n  ## Options\n\n    * `:hash_password` - Hashes the password so it can be stored securely\n      in the database and ensures the password field is cleared to prevent\n      leaks in the logs. If password hashing is not needed and clearing the\n      password field is not desired (like when using this changeset for\n      validations on a LiveView form), this option can be set to `false`.\n      Defaults to `true`.\n  \"\"\"\n  def registration_changeset(user, attrs, opts \\\\ []) do\n    user\n    |> cast(attrs, [:email, :name, :password, :is_admin])\n    |> validate_email()\n    |> validate_name()\n    |> validate_password(opts)\n  end\n\n  defp validate_email(changeset) do\n    changeset\n    |> validate_required([:email])\n    |> validate_format(:email, ~r/^[^\\s]+@[^\\s]+$/, message: \"must have the @ sign and no spaces\")\n    |> validate_length(:email, max: 160)\n    |> unsafe_validate_unique(:email, MediaServer.Repo)\n    |> unique_constraint(:email)\n  end\n\n  defp validate_name(changeset) do\n    changeset\n    |> validate_required([:name])\n    |> validate_length(:name, max: 40)\n  end\n\n  defp validate_password(changeset, opts) do\n    changeset\n    |> validate_required([:password])\n    |> validate_length(:password, min: 12, max: 72)\n    # |> validate_format(:password, ~r/[a-z]/, message: \"at least one lower case character\")\n    # |> validate_format(:password, ~r/[A-Z]/, message: \"at least one upper case character\")\n    # |> validate_format(:password, ~r/[!?@#$%^&*_0-9]/, message: \"at least one digit or punctuation character\")\n    |> maybe_hash_password(opts)\n  end\n\n  defp maybe_hash_password(changeset, opts) do\n    hash_password? = Keyword.get(opts, :hash_password, true)\n    password = get_change(changeset, :password)\n\n    if hash_password? && password && changeset.valid? do\n      changeset\n      # If using Bcrypt, then further validate it is at most 72 bytes long\n      |> validate_length(:password, max: 72, count: :bytes)\n      |> put_change(:hashed_password, Bcrypt.hash_pwd_salt(password))\n      |> delete_change(:password)\n    else\n      changeset\n    end\n  end\n\n  @doc \"\"\"\n  A user changeset for changing the email.\n\n  It requires the email to change otherwise an error is added.\n  \"\"\"\n  def email_changeset(user, attrs) do\n    user\n    |> cast(attrs, [:email])\n    |> validate_email()\n    |> case do\n      %{changes: %{email: _}} = changeset -> changeset\n      %{} = changeset -> add_error(changeset, :email, \"did not change\")\n    end\n  end\n\n  @doc \"\"\"\n  A user changeset for changing the password.\n\n  ## Options\n\n    * `:hash_password` - Hashes the password so it can be stored securely\n      in the database and ensures the password field is cleared to prevent\n      leaks in the logs. If password hashing is not needed and clearing the\n      password field is not desired (like when using this changeset for\n      validations on a LiveView form), this option can be set to `false`.\n      Defaults to `true`.\n  \"\"\"\n  def password_changeset(user, attrs, opts \\\\ []) do\n    user\n    |> cast(attrs, [:password])\n    |> validate_confirmation(:password, message: \"does not match password\")\n    |> validate_password(opts)\n  end\n\n  def name_changeset(user, attrs \\\\ %{}) do\n    user\n    |> cast(attrs, [:name])\n    |> validate_name()\n  end\n\n  @doc \"\"\"\n  Confirms the account by setting `confirmed_at`.\n  \"\"\"\n  def confirm_changeset(user) do\n    now = NaiveDateTime.utc_now() |> NaiveDateTime.truncate(:second)\n    change(user, confirmed_at: now)\n  end\n\n  @doc \"\"\"\n  Verifies the password.\n\n  If there is no user or the user doesn't have a password, we call\n  `Bcrypt.no_user_verify/0` to avoid timing attacks.\n  \"\"\"\n  def valid_password?(%MediaServer.Accounts.User{hashed_password: hashed_password}, password)\n      when is_binary(hashed_password) and byte_size(password) > 0 do\n    Bcrypt.verify_pass(password, hashed_password)\n  end\n\n  def valid_password?(_, _) do\n    Bcrypt.no_user_verify()\n    false\n  end\n\n  @doc \"\"\"\n  Validates the current password otherwise adds an error to the changeset.\n  \"\"\"\n  def validate_current_password(changeset, password) do\n    if valid_password?(changeset.data, password) do\n      changeset\n    else\n      add_error(changeset, :current_password, \"is not valid\")\n    end\n  end\nend"},{"coverage":[null,null,null,null,3,3,null,null,null,null,3,null,3,2,null,null,null,null,null,2,null,null,null,null,null,null,1,null,null,null],"name":"lib/media_server_web/live/home_live/index.ex","source":"defmodule MediaServerWeb.HomeLive.Index do\n  use MediaServerWeb, :live_view\n\n  @impl true\n  def handle_params(params, _url, socket) do\n    {:noreply, apply_action(socket, socket.assigns.live_action, params)}\n  end\n\n  defp apply_action(socket, :index, _params) do\n\n    latest_movies = MediaServerWeb.Repositories.Movies.get_latest(7)\n\n    if !Enum.empty?(latest_movies) do\n      {:ok, latest_movie} = latest_movies |> Enum.fetch(0)\n\n      socket\n      |> assign(page_title: \"Home\")\n      |> assign(:latest_movie, latest_movie)\n      |> assign(:latest_movies, latest_movies |> Enum.drop(1))\n      |> assign(:latest_series, MediaServerWeb.Repositories.Series.get_latest(6))\n\n    else\n      socket\n      |> assign(page_title: \"Home\")\n      |> assign(:latest_movie, %{})\n      |> assign(:latest_movies, MediaServerWeb.Repositories.Movies.get_latest(6))\n      |> assign(:latest_series, MediaServerWeb.Repositories.Series.get_latest(6))\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,1,null,null,null,null,2,1,1,null,null,null,null,null,1,null,null,null,null,3,1,1,null,null,null],"name":"lib/media_server_web/live/watch_live/show.ex","source":"defmodule MediaServerWeb.WatchLive.Show do\n  use MediaServerWeb, :live_view\n\n  @impl true\n  def handle_params(%{\"movie\" => movie}, _, socket) do\n    decoded = MediaServerWeb.Repositories.Movies.get_movie(movie)\n\n    {\n      :noreply,\n      socket\n      |> assign(:poster, (Enum.filter(decoded[\"images\"], fn x -> x[\"coverType\"] === \"fanart\" end) |> Enum.at(0))[\"remoteUrl\"])\n      |> assign(:page_title, \"#{ decoded[\"title\"] }\")\n      |> assign(:stream_url, \"/movies/#{ decoded[\"id\"] }/stream\")\n    }\n  end\n\n  @impl true\n  def handle_params(%{\"episode\" => episode}, _, socket) do\n    decoded = MediaServerWeb.Repositories.Series.get_episode(episode)\n\n    {\n      :noreply,\n      socket\n      |> assign(:poster, (Enum.filter(decoded[\"series\"][\"images\"], fn x -> x[\"coverType\"] === \"fanart\" end) |> Enum.at(0))[\"url\"])\n      |> assign(:page_title, \"#{ decoded[\"series\"][\"title\"] }: #{ decoded[\"title\"] }\")\n      |> assign(:stream_url, \"/episodes/#{ decoded[\"id\"] }/stream\")\n    }\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,16,null,null,null,null,null,null,null,null,null,null,null,null,null,null,43,43,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,2,null,null,null,2,null,null],"name":"test/support/conn_case.ex","source":"defmodule MediaServerWeb.ConnCase do\n  @moduledoc \"\"\"\n  This module defines the test case to be used by\n  tests that require setting up a connection.\n\n  Such tests rely on `Phoenix.ConnTest` and also\n  import other functionality to make it easier\n  to build common data structures and query the data layer.\n\n  Finally, if the test case interacts with the database,\n  we enable the SQL sandbox, so changes done to the database\n  are reverted at the end of every test. If you are using\n  PostgreSQL, you can even run database tests asynchronously\n  by setting `use MediaServerWeb.ConnCase, async: true`, although\n  this option is not recommended for other databases.\n  \"\"\"\n\n  use ExUnit.CaseTemplate\n\n  using do\n    quote do\n      # Import conveniences for testing with connections\n      import Plug.Conn\n      import Phoenix.ConnTest\n      import MediaServerWeb.ConnCase\n\n      alias MediaServerWeb.Router.Helpers, as: Routes\n\n      # The default endpoint for testing\n      @endpoint MediaServerWeb.Endpoint\n    end\n  end\n\n  setup tags do\n    pid = Ecto.Adapters.SQL.Sandbox.start_owner!(MediaServer.Repo, shared: not tags[:async])\n    on_exit(fn -> Ecto.Adapters.SQL.Sandbox.stop_owner(pid) end)\n    {:ok, conn: Phoenix.ConnTest.build_conn()}\n  end\n\n  @doc \"\"\"\n  Setup helper that registers and logs in users.\n\n      setup :register_and_log_in_user\n\n  It stores an updated connection and a registered user in the\n  test context.\n  \"\"\"\n  def register_and_log_in_user(%{conn: conn}) do\n    user = MediaServer.AccountsFixtures.user_fixture()\n    %{conn: log_in_user(conn, user), user: user}\n  end\n\n  @doc \"\"\"\n  Logs the given `user` into the `conn`.\n\n  It returns an updated `conn`.\n  \"\"\"\n  def log_in_user(conn, user) do\n    token = MediaServer.Accounts.generate_user_session_token(user)\n\n    conn\n    |> Phoenix.ConnTest.init_test_session(%{})\n    |> Plug.Conn.put_session(:user_token, token)\n  end\nend"},{"coverage":[null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,null,null,1,1,null,null],"name":"lib/media_server_web/live/series_live/show.ex","source":"defmodule MediaServerWeb.SeriesLive.Show do\n  use MediaServerWeb, :live_view\n\n  @impl true\n  def handle_params(%{\"serie\" => serie}, _, socket) do\n    decoded = MediaServerWeb.Repositories.Series.get_serie(serie)\n\n    {\n      :noreply,\n      socket\n      |> assign(:page_title, decoded[\"title\"])\n      |> assign(:decoded, decoded)\n      |> assign(:episodes, MediaServerWeb.Repositories.Series.get_episodes(serie))\n    }\n  end\n\n  @impl true\n  def handle_event(\"play\", %{\"episode\" => episode}, socket) do\n    {:noreply, push_redirect(socket, to: \"/episodes/#{ episode }/watch\")}\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/media_server_web/endpoint.ex","source":"defmodule MediaServerWeb.Endpoint do\n  use Phoenix.Endpoint, otp_app: :media_server\n\n  # The session will be stored in the cookie and signed,\n  # this means its contents can be read but not tampered with.\n  # Set :encryption_salt if you would also like to encrypt it.\n  @session_options [\n    store: :cookie,\n    key: \"_media_server_key\",\n    signing_salt: \"iVsp22bp\"\n  ]\n\n  socket \"/live\", Phoenix.LiveView.Socket, websocket: [connect_info: [session: @session_options]]\n\n  socket \"/socket\", MediaServerWeb.UserSocket, websocket: true, longpoll: false\n\n  # Serve at \"/\" the static files from \"priv/static\" directory.\n  #\n  # You should set gzip to true if you are running phx.digest\n  # when deploying your static files in production.\n  plug Plug.Static,\n    at: \"/\",\n    from: :media_server,\n    gzip: false,\n    only: ~w(assets fonts images favicon.ico robots.txt)\n\n  # Code reloading can be explicitly enabled under the\n  # :code_reloader configuration of your endpoint.\n  if code_reloading? do\n    socket \"/phoenix/live_reload/socket\", Phoenix.LiveReloader.Socket\n    plug Phoenix.LiveReloader\n    plug Phoenix.CodeReloader\n    plug Phoenix.Ecto.CheckRepoStatus, otp_app: :media_server\n  end\n\n  plug Phoenix.LiveDashboard.RequestLogger,\n    param_key: \"request_logger\",\n    cookie_key: \"request_logger\"\n\n  plug Plug.RequestId\n  plug Plug.Telemetry, event_prefix: [:phoenix, :endpoint]\n\n  plug Plug.Parsers,\n    parsers: [:urlencoded, :multipart, :json],\n    pass: [\"*/*\"],\n    json_decoder: Phoenix.json_library()\n\n  plug Plug.MethodOverride\n  plug Plug.Head\n  plug Plug.Session, @session_options\n  plug MediaServerWeb.Router\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null],"name":"lib/media_server_web/channels/user_socket.ex","source":"defmodule MediaServerWeb.UserSocket do\n  use Phoenix.Socket\n\n  # A Socket handler\n  #\n  # It's possible to control the websocket connection and\n  # assign values that can be accessed by your channel topics.\n\n  ## Channels\n\n  channel \"room:*\", MediaServerWeb.RoomChannel\n\n  # Socket params are passed from the client and can\n  # be used to verify and authenticate a user. After\n  # verification, you can put default assigns into\n  # the socket that will be set for all channels, ie\n  #\n  #     {:ok, assign(socket, :user_id, verified_user_id)}\n  #\n  # To deny connection, return `:error`.\n  #\n  # See `Phoenix.Token` documentation for examples in\n  # performing token verification on connect.\n  @impl true\n  def connect(_params, socket, _connect_info) do\n    {:ok, socket}\n  end\n\n  # Socket id's are topics that allow you to identify all sockets for a given user:\n  #\n  #     def id(socket), do: \"user_socket:#{socket.assigns.user_id}\"\n  #\n  # Would allow you to broadcast a \"disconnect\" event and terminate\n  # all active sockets and channels for a given user:\n  #\n  #     Elixir.MediaServerWeb.Endpoint.broadcast(\"user_socket:#{user.id}\", \"disconnect\", %{})\n  #\n  # Returning `nil` makes this socket anonymous.\n  @impl true\n  def id(_socket), do: nil\nend"},{"coverage":[null,null,null,null,null,null,49,null,null,null,null,null,null,null,null,null,null,null,null,3,null,1,3,null,1,3,null,null,1,1,null,null,18,null,2,2,null,1,null,null,null,null,null,2,22,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/media_server_web/router.ex","source":"defmodule MediaServerWeb.Router do\n  use MediaServerWeb, :router\n\n  import MediaServerWeb.UserAuth\n  import Phoenix.LiveDashboard.Router\n\n  pipeline :browser do\n    plug :accepts, [\"html\"]\n    plug :fetch_session\n    plug :fetch_live_flash\n    plug :put_root_layout, {MediaServerWeb.LayoutView, :root}\n    plug :protect_from_forgery\n    plug :put_secure_browser_headers\n    plug :fetch_current_user\n  end\n\n  scope \"/\", MediaServerWeb do\n    pipe_through [:browser, :require_authenticated_user]\n\n    live \"/\", HomeLive.Index, :index\n\n    live \"/movies\", MoviesLive.Index, :index\n    live \"/movies/:movie\", MoviesLive.Show, :show\n\n    live \"/series\", SeriesLive.Index, :index\n    live \"/series/:serie\", SeriesLive.Show, :show\n\n    live_session :watch, root_layout: {MediaServerWeb.WatchView, \"watch.html\"} do\n      live \"/movies/:movie/watch\", WatchLive.Show, :show\n      live \"/episodes/:episode/watch\", WatchLive.Show, :show\n    end\n\n    live \"/settings\", SettingsLive.Index, :index\n\n    get \"/movies/:movie/stream\", StreamController, :show\n    get \"/episodes/:episode/stream\", StreamController, :show\n\n    delete \"/logout\", UserSessionController, :delete\n  end\n\n  scope \"/\", MediaServerWeb do\n    pipe_through [:browser, :redirect_if_user_is_authenticated]\n\n    get \"/login\", UserSessionController, :new\n    post \"/login\", UserSessionController, :create\n  end\n\n  # Enables the Swoosh mailbox preview in development.\n  #\n  # Note that preview only shows emails that were sent by the same\n  # node running the Phoenix server.\n  if Mix.env() == :dev do\n    scope \"/dev\" do\n      pipe_through :browser\n\n      live_dashboard \"/dashboard\", metrics: MediaServerWeb.Telemetry\n\n      forward \"/mailbox\", Plug.Swoosh.MailboxPreview\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,27,27,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,88,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,6,null,null,null,null,null,null,null,null,null,3,null,3,3,1,null,null,null,null,null,null,null,1,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,5,null,5,5,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,5,null,null,null,null,null,null,null,null,5,2,3,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,38,38,38,null,null,null,null,null,null,51,51,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,null,null,4,4,4,null,null,null,null,2,2,2,2,null,null,null,null,null,null,null,null,null,2,2,1,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,4,4,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,2,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,2,2,null,null,null],"name":"lib/media_server/accounts.ex","source":"defmodule MediaServer.Accounts do\n  @moduledoc \"\"\"\n  The Accounts context.\n  \"\"\"\n\n  import Ecto.Query, warn: false\n  alias MediaServer.Repo\n\n  alias MediaServer.Accounts.{User, UserToken, UserNotifier}\n\n  ## Database getters\n\n  @doc \"\"\"\n  Gets a user by email.\n\n  ## Examples\n\n      iex> get_user_by_email(\"foo@example.com\")\n      %User{}\n\n      iex> get_user_by_email(\"unknown@example.com\")\n      nil\n\n  \"\"\"\n  def get_user_by_email(email) when is_binary(email) do\n    Repo.get_by(User, email: email)\n  end\n\n  @doc \"\"\"\n  Gets a user by email and password.\n\n  ## Examples\n\n      iex> get_user_by_email_and_password(\"foo@example.com\", \"correct_password\")\n      %User{}\n\n      iex> get_user_by_email_and_password(\"foo@example.com\", \"invalid_password\")\n      nil\n\n  \"\"\"\n  def get_user_by_email_and_password(email, password)\n      when is_binary(email) and is_binary(password) do\n    user = Repo.get_by(User, email: email)\n    if User.valid_password?(user, password), do: user\n  end\n\n  @doc \"\"\"\n  Gets a single user.\n\n  Raises `Ecto.NoResultsError` if the User does not exist.\n\n  ## Examples\n\n      iex> get_user!(123)\n      %User{}\n\n      iex> get_user!(456)\n      ** (Ecto.NoResultsError)\n\n  \"\"\"\n  def get_user!(id), do: Repo.get!(User, id)\n\n  ## User registration\n\n  @doc \"\"\"\n  Registers a user.\n\n  ## Examples\n\n      iex> register_user(%{field: value})\n      {:ok, %User{}}\n\n      iex> register_user(%{field: bad_value})\n      {:error, %Ecto.Changeset{}}\n\n  \"\"\"\n  def register_user(attrs) do\n    %User{}\n    |> User.registration_changeset(attrs)\n    |> Repo.insert()\n  end\n\n  @doc \"\"\"\n  Returns an `%Ecto.Changeset{}` for tracking user changes.\n\n  ## Examples\n\n      iex> change_user_registration(user)\n      %Ecto.Changeset{data: %User{}}\n\n  \"\"\"\n  def change_user_registration(%User{} = user, attrs \\\\ %{}) do\n    User.registration_changeset(user, attrs, hash_password: false)\n  end\n\n  ## Settings\n\n  @doc \"\"\"\n  Returns an `%Ecto.Changeset{}` for changing the user email.\n\n  ## Examples\n\n      iex> change_user_email(user)\n      %Ecto.Changeset{data: %User{}}\n\n  \"\"\"\n  def change_user_email(user, attrs \\\\ %{}) do\n    User.email_changeset(user, attrs)\n  end\n\n  @doc \"\"\"\n  Emulates that the email will change without actually changing\n  it in the database.\n\n  ## Examples\n\n      iex> apply_user_email(user, \"valid password\", %{email: ...})\n      {:ok, %User{}}\n\n      iex> apply_user_email(user, \"invalid password\", %{email: ...})\n      {:error, %Ecto.Changeset{}}\n\n  \"\"\"\n  def apply_user_email(user, password, attrs) do\n    user\n    |> User.email_changeset(attrs)\n    |> User.validate_current_password(password)\n    |> Ecto.Changeset.apply_action(:update)\n  end\n\n  @doc \"\"\"\n  Updates the user email using the given token.\n\n  If the token matches, the user email is updated and the token is deleted.\n  The confirmed_at date is also updated to the current time.\n  \"\"\"\n  def update_user_email(user, token) do\n    context = \"change:#{user.email}\"\n\n    with {:ok, query} <- UserToken.verify_change_email_token_query(token, context),\n         %UserToken{sent_to: email} <- Repo.one(query),\n         {:ok, _} <- Repo.transaction(user_email_multi(user, email, context)) do\n      :ok\n    else\n      _ -> :error\n    end\n  end\n\n  defp user_email_multi(user, email, context) do\n    changeset = user |> User.email_changeset(%{email: email}) |> User.confirm_changeset()\n\n    Ecto.Multi.new()\n    |> Ecto.Multi.update(:user, changeset)\n    |> Ecto.Multi.delete_all(:tokens, UserToken.user_and_contexts_query(user, [context]))\n  end\n\n  @doc \"\"\"\n  Delivers the update email instructions to the given user.\n\n  ## Examples\n\n      iex> deliver_update_email_instructions(user, current_email, &Routes.user_update_email_url(conn, :edit, &1))\n      {:ok, %{to: ..., body: ...}}\n\n  \"\"\"\n  def deliver_update_email_instructions(%User{} = user, current_email, update_email_url_fun)\n      when is_function(update_email_url_fun, 1) do\n    {encoded_token, user_token} = UserToken.build_email_token(user, \"change:#{current_email}\")\n\n    Repo.insert!(user_token)\n    UserNotifier.deliver_update_email_instructions(user, update_email_url_fun.(encoded_token))\n  end\n\n  @doc \"\"\"\n  Returns an `%Ecto.Changeset{}` for changing the user password.\n\n  ## Examples\n\n      iex> change_user_password(user)\n      %Ecto.Changeset{data: %User{}}\n\n  \"\"\"\n  def change_user_password(user, attrs \\\\ %{}) do\n    User.password_changeset(user, attrs, hash_password: false)\n  end\n\n  @doc \"\"\"\n  Updates the user password.\n\n  ## Examples\n\n      iex> update_user_password(user, \"valid password\", %{password: ...})\n      {:ok, %User{}}\n\n      iex> update_user_password(user, \"invalid password\", %{password: ...})\n      {:error, %Ecto.Changeset{}}\n\n  \"\"\"\n  def update_user_password(user, password, attrs) do\n    changeset =\n      user\n      |> User.password_changeset(attrs)\n      |> User.validate_current_password(password)\n\n    Ecto.Multi.new()\n    |> Ecto.Multi.update(:user, changeset)\n    |> Ecto.Multi.delete_all(:tokens, UserToken.user_and_contexts_query(user, :all))\n    |> Repo.transaction()\n    |> case do\n      {:ok, %{user: user}} -> {:ok, user}\n      {:error, :user, changeset, _} -> {:error, changeset}\n    end\n  end\n\n  def update_user_name(user, attrs) do\n    user\n    |> User.name_changeset(attrs)\n    |> Repo.update()\n  end\n\n  ## Session\n\n  @doc \"\"\"\n  Generates a session token.\n  \"\"\"\n  def generate_user_session_token(user) do\n    {token, user_token} = UserToken.build_session_token(user)\n    Repo.insert!(user_token)\n    token\n  end\n\n  @doc \"\"\"\n  Gets the user with the given signed token.\n  \"\"\"\n  def get_user_by_session_token(token) do\n    {:ok, query} = UserToken.verify_session_token_query(token)\n    Repo.one(query)\n  end\n\n  @doc \"\"\"\n  Deletes the signed token with the given context.\n  \"\"\"\n  def delete_session_token(token) do\n    Repo.delete_all(UserToken.token_and_context_query(token, \"session\"))\n    :ok\n  end\n\n  ## Confirmation\n\n  @doc \"\"\"\n  Delivers the confirmation email instructions to the given user.\n\n  ## Examples\n\n      iex> deliver_user_confirmation_instructions(user, &Routes.user_confirmation_url(conn, :edit, &1))\n      {:ok, %{to: ..., body: ...}}\n\n      iex> deliver_user_confirmation_instructions(confirmed_user, &Routes.user_confirmation_url(conn, :edit, &1))\n      {:error, :already_confirmed}\n\n  \"\"\"\n  def deliver_user_confirmation_instructions(%User{} = user, confirmation_url_fun)\n      when is_function(confirmation_url_fun, 1) do\n    if user.confirmed_at do\n      {:error, :already_confirmed}\n    else\n      {encoded_token, user_token} = UserToken.build_email_token(user, \"confirm\")\n      Repo.insert!(user_token)\n      UserNotifier.deliver_confirmation_instructions(user, confirmation_url_fun.(encoded_token))\n    end\n  end\n\n  def deliver_user_invitation_instructions(%User{} = user, password) do\n    {encoded_token, user_token} = UserToken.build_email_token(user, \"invitation\")\n    Repo.insert!(user_token)\n    UserNotifier.deliver_invitation_instructions(user, password)\n    encoded_token\n  end\n\n  @doc \"\"\"\n  Confirms a user by the given token.\n\n  If the token matches, the user account is marked as confirmed\n  and the token is deleted.\n  \"\"\"\n  def confirm_user(token) do\n    with {:ok, query} <- UserToken.verify_email_token_query(token, \"confirm\"),\n         %User{} = user <- Repo.one(query),\n         {:ok, %{user: user}} <- Repo.transaction(confirm_user_multi(user)) do\n      {:ok, user}\n    else\n      _ -> :error\n    end\n  end\n\n  defp confirm_user_multi(user) do\n    Ecto.Multi.new()\n    |> Ecto.Multi.update(:user, User.confirm_changeset(user))\n    |> Ecto.Multi.delete_all(:tokens, UserToken.user_and_contexts_query(user, [\"confirm\"]))\n  end\n\n  ## Reset password\n\n  @doc \"\"\"\n  Delivers the reset password email to the given user.\n\n  ## Examples\n\n      iex> deliver_user_reset_password_instructions(user, &Routes.user_reset_password_url(conn, :edit, &1))\n      {:ok, %{to: ..., body: ...}}\n\n  \"\"\"\n  def deliver_user_reset_password_instructions(%User{} = user, reset_password_url_fun)\n      when is_function(reset_password_url_fun, 1) do\n    {encoded_token, user_token} = UserToken.build_email_token(user, \"reset_password\")\n    Repo.insert!(user_token)\n    UserNotifier.deliver_reset_password_instructions(user, reset_password_url_fun.(encoded_token))\n  end\n\n  @doc \"\"\"\n  Gets the user by reset password token.\n\n  ## Examples\n\n      iex> get_user_by_reset_password_token(\"validtoken\")\n      %User{}\n\n      iex> get_user_by_reset_password_token(\"invalidtoken\")\n      nil\n\n  \"\"\"\n  def get_user_by_reset_password_token(token) do\n    with {:ok, query} <- UserToken.verify_email_token_query(token, \"reset_password\"),\n         %User{} = user <- Repo.one(query) do\n      user\n    else\n      _ -> nil\n    end\n  end\n\n  @doc \"\"\"\n  Resets the user password.\n\n  ## Examples\n\n      iex> reset_user_password(user, %{password: \"new long password\", password_confirmation: \"new long password\"})\n      {:ok, %User{}}\n\n      iex> reset_user_password(user, %{password: \"valid\", password_confirmation: \"not the same\"})\n      {:error, %Ecto.Changeset{}}\n\n  \"\"\"\n  def reset_user_password(user, attrs) do\n    Ecto.Multi.new()\n    |> Ecto.Multi.update(:user, User.password_changeset(user, attrs))\n    |> Ecto.Multi.delete_all(:tokens, UserToken.user_and_contexts_query(user, :all))\n    |> Repo.transaction()\n    |> case do\n      {:ok, %{user: user}} -> {:ok, user}\n      {:error, :user, changeset, _} -> {:error, changeset}\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,null,1,1,null,null],"name":"lib/media_server_web/live/movies_live/show.ex","source":"defmodule MediaServerWeb.MoviesLive.Show do\n  use MediaServerWeb, :live_view\n\n  @impl true\n  def handle_params(%{\"movie\" => movie}, _, socket) do\n    decoded = MediaServerWeb.Repositories.Movies.get_movie(movie)\n\n    {\n      :noreply,\n      socket\n      |> assign(:page_title, decoded[\"title\"])\n      |> assign(:decoded, decoded)\n    }\n  end\n\n  @impl true\n  def handle_event(\"play\", %{\"movie\" => movie}, socket) do\n    {:noreply, push_redirect(socket, to: \"/movies/#{ movie }/watch\")}\n  end\nend"},{"coverage":[null,null,null,null,null,null,3,null,null,null,null,null,null,3,3,null,3,3,3,3,null,null,3,null,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null],"name":"lib/media_server_web/channels/room_channel.ex","source":"defmodule MediaServerWeb.RoomChannel do\n  use MediaServerWeb, :channel\n  alias MediaServerWeb.Presence\n\n  @impl true\n  def join(\"room:lobby\", %{\"user_id\" => user_id, \"user_name\" => user_name, \"page_title\" => page_title, \"current_location\" => current_location}, socket) do\n    send(self(), :after_join)\n\n    {:ok, assign(socket, %{user_id: user_id, user_name: user_name, page_title: page_title, current_location: current_location})}\n  end\n\n  @impl true\n  def handle_info(:after_join, socket) do\n    {:ok, _} =\n      Presence.track(socket, socket.assigns.user_id, %{\n        online_at: inspect(System.system_time(:second)),\n        user_id: socket.assigns.user_id,\n        user_name: socket.assigns.user_name,\n        page_title: socket.assigns.page_title,\n        current_location: socket.assigns.current_location\n      })\n\n    push(socket, \"presence_state\", Presence.list(socket))\n    {:noreply, socket}\n  end\n\n  # Channels can be used in a request/response fashion\n  # by sending replies to requests from the client\n  @impl true\n  def handle_in(\"ping\", payload, socket) do\n    {:reply, {:ok, payload}, socket}\n  end\n\n  # It is also common to receive messages from the client and\n  # broadcast to everyone in the current topic (room:lobby).\n  @impl true\n  def handle_in(\"shout\", payload, socket) do\n    broadcast socket, \"shout\", payload\n    {:noreply, socket}\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,null,18,null,18,null,null,0,null,null,18,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,22,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,null,null,null,1,null,1,null,null,null,null,0,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,19,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,null,19,null,19,null,null,16,null,null,3,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,24,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,null,null,null,3,null,3,null,null,null,null,2,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,21,null,null],"name":"lib/media_server/integrations.ex","source":"defmodule MediaServer.Integrations do\n  @moduledoc \"\"\"\n  The Integrations context.\n  \"\"\"\n\n  import Ecto.Query, warn: false\n  alias MediaServer.Repo\n\n  alias MediaServer.Integrations.Sonarr\n\n  @doc \"\"\"\n  Returns the list of sonarrs.\n\n  ## Examples\n\n      iex> list_sonarrs()\n      [%Sonarr{}, ...]\n\n  \"\"\"\n  def list_sonarrs do\n    Repo.all(Sonarr)\n  end\n\n  @doc \"\"\"\n  Gets a single sonarr.\n\n  Raises `Ecto.NoResultsError` if the Sonarr does not exist.\n\n  ## Examples\n\n      iex> get_sonarr!(123)\n      %Sonarr{}\n\n      iex> get_sonarr!(456)\n      ** (Ecto.NoResultsError)\n\n  \"\"\"\n  def get_sonarr!(id), do: Repo.get!(Sonarr, id)\n\n  def get_first_sonarr() do\n    sonarr = Sonarr |> first |> Repo.one\n\n    case sonarr do\n\n      :nil ->\n        change_sonarr(%Sonarr{})\n\n      _ ->\n        change_sonarr(sonarr)\n    end\n  end\n\n  @doc \"\"\"\n  Creates a sonarr.\n\n  ## Examples\n\n      iex> create_sonarr(%{field: value})\n      {:ok, %Sonarr{}}\n\n      iex> create_sonarr(%{field: bad_value})\n      {:error, %Ecto.Changeset{}}\n\n  \"\"\"\n  def create_sonarr(attrs \\\\ %{}) do\n    %Sonarr{}\n    |> Sonarr.changeset(attrs)\n    |> Repo.insert()\n  end\n\n  @doc \"\"\"\n  Updates a sonarr.\n\n  ## Examples\n\n      iex> update_sonarr(sonarr, %{field: new_value})\n      {:ok, %Sonarr{}}\n\n      iex> update_sonarr(sonarr, %{field: bad_value})\n      {:error, %Ecto.Changeset{}}\n\n  \"\"\"\n  def update_sonarr(%Sonarr{} = sonarr, attrs) do\n    sonarr\n    |> Sonarr.changeset(attrs)\n    |> Repo.update()\n  end\n\n  def update_or_create_sonarr(attrs \\\\ %{}) do\n\n    sonarr = Sonarr |> first |> Repo.one\n\n    case sonarr do\n\n      :nil ->\n        %Sonarr{}\n        |> Sonarr.changeset(attrs)\n        |> Repo.insert()\n\n      _ ->\n        update_sonarr(sonarr, attrs)\n    end\n  end\n\n  @doc \"\"\"\n  Deletes a sonarr.\n\n  ## Examples\n\n      iex> delete_sonarr(sonarr)\n      {:ok, %Sonarr{}}\n\n      iex> delete_sonarr(sonarr)\n      {:error, %Ecto.Changeset{}}\n\n  \"\"\"\n  def delete_sonarr(%Sonarr{} = sonarr) do\n    Repo.delete(sonarr)\n  end\n\n  @doc \"\"\"\n  Returns an `%Ecto.Changeset{}` for tracking sonarr changes.\n\n  ## Examples\n\n      iex> change_sonarr(sonarr)\n      %Ecto.Changeset{data: %Sonarr{}}\n\n  \"\"\"\n  def change_sonarr(%Sonarr{} = sonarr, attrs \\\\ %{}) do\n    Sonarr.changeset(sonarr, attrs)\n  end\n\n  alias MediaServer.Integrations.Radarr\n\n  @doc \"\"\"\n  Returns the list of radarrs.\n\n  ## Examples\n\n      iex> list_radarrs()\n      [%Radarr{}, ...]\n\n  \"\"\"\n  def list_radarrs do\n    Repo.all(Radarr)\n  end\n\n  @doc \"\"\"\n  Gets a single radarr.\n\n  Raises `Ecto.NoResultsError` if the Radarr does not exist.\n\n  ## Examples\n\n      iex> get_radarr!(123)\n      %Radarr{}\n\n      iex> get_radarr!(456)\n      ** (Ecto.NoResultsError)\n\n  \"\"\"\n  def get_radarr!(id), do: Repo.get!(Radarr, id)\n\n  def get_first_radarr() do\n    radarr = Radarr |> first |> Repo.one\n\n    case radarr do\n\n      :nil ->\n        change_radarr(%Radarr{})\n\n      _ ->\n        change_radarr(radarr)\n    end\n  end\n\n  @doc \"\"\"\n  Creates a radarr.\n\n  ## Examples\n\n      iex> create_radarr(%{field: value})\n      {:ok, %Radarr{}}\n\n      iex> create_radarr(%{field: bad_value})\n      {:error, %Ecto.Changeset{}}\n\n  \"\"\"\n  def create_radarr(attrs \\\\ %{}) do\n    %Radarr{}\n    |> Radarr.changeset(attrs)\n    |> Repo.insert()\n  end\n\n  @doc \"\"\"\n  Updates a radarr.\n\n  ## Examples\n\n      iex> update_radarr(radarr, %{field: new_value})\n      {:ok, %Radarr{}}\n\n      iex> update_radarr(radarr, %{field: bad_value})\n      {:error, %Ecto.Changeset{}}\n\n  \"\"\"\n  def update_radarr(%Radarr{} = radarr, attrs) do\n    radarr\n    |> Radarr.changeset(attrs)\n    |> Repo.update()\n  end\n\n  def update_or_create_radarr(attrs \\\\ %{}) do\n\n    radarr = Radarr |> first |> Repo.one\n\n    case radarr do\n\n      :nil ->\n        %Radarr{}\n        |> Radarr.changeset(attrs)\n        |> Repo.insert()\n\n      _ ->\n        update_radarr(radarr, attrs)\n    end\n  end\n\n  @doc \"\"\"\n  Deletes a radarr.\n\n  ## Examples\n\n      iex> delete_radarr(radarr)\n      {:ok, %Radarr{}}\n\n      iex> delete_radarr(radarr)\n      {:error, %Ecto.Changeset{}}\n\n  \"\"\"\n  def delete_radarr(%Radarr{} = radarr) do\n    Repo.delete(radarr)\n  end\n\n  @doc \"\"\"\n  Returns an `%Ecto.Changeset{}` for tracking radarr changes.\n\n  ## Examples\n\n      iex> change_radarr(radarr)\n      %Ecto.Changeset{data: %Radarr{}}\n\n  \"\"\"\n  def change_radarr(%Radarr{} = radarr, attrs \\\\ %{}) do\n    Radarr.changeset(radarr, attrs)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/media_server_web/gettext.ex","source":"defmodule MediaServerWeb.Gettext do\n  @moduledoc \"\"\"\n  A module providing Internationalization with a gettext-based API.\n\n  By using [Gettext](https://hexdocs.pm/gettext),\n  your module gains a set of macros for translations, for example:\n\n      import MediaServerWeb.Gettext\n\n      # Simple translation\n      gettext(\"Here is the string to translate\")\n\n      # Plural translation\n      ngettext(\"Here is the string to translate\",\n               \"Here are the strings to translate\",\n               3)\n\n      # Domain-based translation\n      dgettext(\"errors\", \"Here is the error message to translate\")\n\n  See the [Gettext Docs](https://hexdocs.pm/gettext) for detailed usage.\n  \"\"\"\n  use Gettext, otp_app: :media_server\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,26,26,null,null,null,null,26,null,26,null,null,null,3,null,null,null,23,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,30,null,null,null,null,null,null,null,null,4,4,null,4,1,null,null,null,null,null,4,null,null,null,null,null,null,null,52,52,52,null,null,null,52,null,null,25,null,25,null,null,null,null,null,null,null,null,null,null,null,26,null,null,2,null,24,null,null,null,null,null,null,null,null,null,null,30,26,null,null,null,null,null,4,null,null,null,null,3,null,null,1,null,26,null],"name":"lib/media_server_web/controllers/user_auth.ex","source":"defmodule MediaServerWeb.UserAuth do\n  import Plug.Conn\n  import Phoenix.Controller\n\n  alias MediaServer.Accounts\n  alias MediaServerWeb.Router.Helpers, as: Routes\n\n  # Make the remember me cookie valid for 60 days.\n  # If you want bump or reduce this value, also change\n  # the token expiry itself in UserToken.\n  @max_age 60 * 60 * 24 * 60\n  @remember_me_cookie \"_media_server_web_user_remember_me\"\n  @remember_me_options [sign: true, max_age: @max_age, same_site: \"Lax\"]\n\n  @doc \"\"\"\n  Logs the user in.\n\n  It renews the session ID and clears the whole session\n  to avoid fixation attacks. See the renew_session\n  function to customize this behaviour.\n\n  It also sets a `:live_socket_id` key in the session,\n  so LiveView sessions are identified and automatically\n  disconnected on log out. The line can be safely removed\n  if you are not using LiveView.\n  \"\"\"\n  def log_in_user(conn, user, params \\\\ %{}) do\n    token = Accounts.generate_user_session_token(user)\n    user_return_to = get_session(conn, :user_return_to)\n\n    conn\n    |> renew_session()\n    |> put_session(:user_token, token)\n    |> put_session(:live_socket_id, \"users_sessions:#{Base.url_encode64(token)}\")\n    |> maybe_write_remember_me_cookie(token, params)\n    |> redirect(to: user_return_to || signed_in_path(conn))\n  end\n\n  defp maybe_write_remember_me_cookie(conn, token, %{\"remember_me\" => \"true\"}) do\n    put_resp_cookie(conn, @remember_me_cookie, token, @remember_me_options)\n  end\n\n  defp maybe_write_remember_me_cookie(conn, _token, _params) do\n    conn\n  end\n\n  # This function renews the session ID and erases the whole\n  # session to avoid fixation attacks. If there is any data\n  # in the session you may want to preserve after log in/log out,\n  # you must explicitly fetch the session data before clearing\n  # and then immediately set it after clearing, for example:\n  #\n  #     defp renew_session(conn) do\n  #       preferred_locale = get_session(conn, :preferred_locale)\n  #\n  #       conn\n  #       |> configure_session(renew: true)\n  #       |> clear_session()\n  #       |> put_session(:preferred_locale, preferred_locale)\n  #     end\n  #\n  defp renew_session(conn) do\n    conn\n    |> configure_session(renew: true)\n    |> clear_session()\n  end\n\n  @doc \"\"\"\n  Logs the user out.\n\n  It clears all session data for safety. See renew_session.\n  \"\"\"\n  def log_out_user(conn) do\n    user_token = get_session(conn, :user_token)\n    user_token && Accounts.delete_session_token(user_token)\n\n    if live_socket_id = get_session(conn, :live_socket_id) do\n      MediaServerWeb.Endpoint.broadcast(live_socket_id, \"disconnect\", %{})\n    end\n\n    conn\n    |> renew_session()\n    |> delete_resp_cookie(@remember_me_cookie)\n    |> redirect(to: \"/login\")\n  end\n\n  @doc \"\"\"\n  Authenticates the user by looking into the session\n  and remember me token.\n  \"\"\"\n  def fetch_current_user(conn, _opts) do\n    {user_token, conn} = ensure_user_token(conn)\n    user = user_token && Accounts.get_user_by_session_token(user_token)\n    assign(conn, :current_user, user)\n  end\n\n  defp ensure_user_token(conn) do\n    if user_token = get_session(conn, :user_token) do\n      {user_token, conn}\n    else\n      conn = fetch_cookies(conn, signed: [@remember_me_cookie])\n\n      if user_token = conn.cookies[@remember_me_cookie] do\n        {user_token, put_session(conn, :user_token, user_token)}\n      else\n        {nil, conn}\n      end\n    end\n  end\n\n  @doc \"\"\"\n  Used for routes that require the user to not be authenticated.\n  \"\"\"\n  def redirect_if_user_is_authenticated(conn, _opts) do\n    if conn.assigns[:current_user] do\n      conn\n      |> redirect(to: signed_in_path(conn))\n      |> halt()\n    else\n      conn\n    end\n  end\n\n  @doc \"\"\"\n  Used for routes that require the user to be authenticated.\n\n  If you want to enforce the user email is confirmed before\n  they use the application at all, here would be a good place.\n  \"\"\"\n  def require_authenticated_user(conn, _opts) do\n    if conn.assigns[:current_user] do\n      conn\n    else\n      conn\n      |> put_flash(:error, \"You must log in to access this page.\")\n      |> maybe_store_return_to()\n      |> redirect(to: Routes.user_session_path(conn, :new))\n      |> halt()\n    end\n  end\n\n  defp maybe_store_return_to(%{method: \"GET\"} = conn) do\n    put_session(conn, :user_return_to, current_path(conn))\n  end\n\n  defp maybe_store_return_to(conn), do: conn\n\n  defp signed_in_path(_conn), do: \"/\"\nend"},{"coverage":[null,null,null,null,null,null,null,null,null],"name":"lib/media_server_web/views/layout_view.ex","source":"defmodule MediaServerWeb.LayoutView do\n  use MediaServerWeb, :view\n\n  alias Phoenix.LiveView.JS\n\n  # Phoenix LiveDashboard is available only in development by default,\n  # so we instruct Elixir to not warn if the dashboard route is missing.\n  @compile {:no_warn_undefined, {Routes, :live_dashboard_path, 2}}\nend"},{"coverage":[null,null,null,null,null,null,null,1,null,null,null,22,null,22,21,null,null,1,null,null,null,null,null,null,1,null,null],"name":"lib/media_server_web/controllers/user_session_controller.ex","source":"defmodule MediaServerWeb.UserSessionController do\n  use MediaServerWeb, :controller\n\n  alias MediaServer.Accounts\n  alias MediaServerWeb.UserAuth\n\n  def new(conn, _params) do\n    render(conn, \"new.html\", error_message: nil)\n  end\n\n  def create(conn, %{\"user\" => user_params}) do\n    %{\"email\" => email, \"password\" => password} = user_params\n\n    if user = Accounts.get_user_by_email_and_password(email, password) do\n      UserAuth.log_in_user(conn, user, user_params)\n    else\n      # In order to prevent user enumeration attacks, don't disclose whether the email is registered.\n      render(conn, \"new.html\", error_message: \"Invalid email or password\")\n    end\n  end\n\n  def delete(conn, _params) do\n    conn\n    |> put_flash(:info, \"Logged out successfully.\")\n    |> UserAuth.log_out_user()\n  end\nend"},{"coverage":[null,null,null,null,null],"name":"lib/media_server/repo.ex","source":"defmodule MediaServer.Repo do\n  use Ecto.Repo,\n    otp_app: :media_server,\n    adapter: Ecto.Adapters.Postgres\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,null,null,null,null,null,null,0,null,null,null],"name":"lib/media_server/application.ex","source":"defmodule MediaServer.Application do\n  # See https://hexdocs.pm/elixir/Application.html\n  # for more information on OTP Applications\n  @moduledoc false\n\n  use Application\n\n  @impl true\n  def start(_type, _args) do\n    children = [\n      # Start the Ecto repository\n      MediaServer.Repo,\n      # Start the Telemetry supervisor\n      MediaServerWeb.Telemetry,\n      # Start the PubSub system\n      {Phoenix.PubSub, name: MediaServer.PubSub},\n      # Start the Endpoint (http/https)\n      MediaServerWeb.Endpoint,\n      # Start a worker by calling: MediaServer.Worker.start_link(arg)\n      # {MediaServer.Worker, arg}\n      MediaServerWeb.Presence,\n    ]\n\n    # See https://hexdocs.pm/elixir/Supervisor.html\n    # for other strategies and supported options\n    opts = [strategy: :one_for_one, name: MediaServer.Supervisor]\n    Supervisor.start_link(children, opts)\n  end\n\n  # Tell Phoenix to update the endpoint configuration\n  # whenever the application is updated.\n  @impl true\n  def config_change(changed, _new, removed) do\n    MediaServerWeb.Endpoint.config_change(changed, removed)\n    :ok\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,18,null,null,null,null,18,18,null,null,null,null,null,null,18,null,null,18,null,null],"name":"lib/media_server_web/live/settings_live/index.ex","source":"defmodule MediaServerWeb.SettingsLive.Index do\n  use MediaServerWeb, :live_view\n\n  alias MediaServer.Repo\n  alias MediaServer.Accounts\n  alias MediaServer.Accounts.User\n  alias MediaServer.Integrations\n\n  @impl true\n  def mount(_params, session, socket) do\n    user = Accounts.get_user_by_session_token(session[\"user_token\"])\n    {:ok, socket |> assign(:current_user, user)}\n  end\n\n  @impl true\n  def handle_params(params, _url, socket) do\n    {:noreply, apply_action(socket, socket.assigns.live_action, params)}\n  end\n\n  defp apply_action(socket, :index, _params) do\n    socket\n    |> assign(:page_title, \"Settings\")\n    |> assign(:users, Repo.all(User))\n    |> assign(:user_name, User.name_changeset(socket.assigns.current_user))\n    |> assign(:user, User.registration_changeset(%User{}, %{}))\n    |> assign(:radarr, Integrations.get_first_radarr())\n    |> assign(:sonarr, Integrations.get_first_sonarr())\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,114,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null],"name":"lib/media_server_web/views/error_helpers.ex","source":"defmodule MediaServerWeb.ErrorHelpers do\n  @moduledoc \"\"\"\n  Conveniences for translating and building error messages.\n  \"\"\"\n\n  use Phoenix.HTML\n\n  @doc \"\"\"\n  Generates tag for inlined form input errors.\n  \"\"\"\n  def error_tag(form, field) do\n    Enum.map(Keyword.get_values(form.errors, field), fn error ->\n      content_tag(:span, translate_error(error),\n        class: \"invalid-feedback\",\n        phx_feedback_for: input_name(form, field)\n      )\n    end)\n  end\n\n  @doc \"\"\"\n  Translates an error message using gettext.\n  \"\"\"\n  def translate_error({msg, opts}) do\n    # When using gettext, we typically pass the strings we want\n    # to translate as a static argument:\n    #\n    #     # Translate \"is invalid\" in the \"errors\" domain\n    #     dgettext(\"errors\", \"is invalid\")\n    #\n    #     # Translate the number of files with plural rules\n    #     dngettext(\"errors\", \"1 file\", \"%{count} files\", count)\n    #\n    # Because the error messages we show in our forms and APIs\n    # are defined inside Ecto, we need to translate them dynamically.\n    # This requires us to call the Gettext module passing our gettext\n    # backend as first argument.\n    #\n    # Note we use the \"errors\" domain, which means translations\n    # should be written to the errors.po file. The :count option is\n    # set by Ecto and indicates we should also apply plural rules.\n    if count = opts[:count] do\n      Gettext.dngettext(MediaServerWeb.Gettext, \"errors\", msg, msg, count, opts)\n    else\n      Gettext.dgettext(MediaServerWeb.Gettext, \"errors\", msg, opts)\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,15,null,null,null,null,null,null,15,null,null,null,null,null,null,null,null,4,null,null,null,4,null,null,null,4,null,null,null,null,null,null,null,null,2,null,null,null,2,null,null,null,null,null,2,2,null,null,null,null,null,null,null,null,null,null,null,4,null,null,null,4,null,null,null,4,null,null,null,null,null,null,null,null,null,null,null,5,null,null,null,5,null,null,null,5,null,null,null,null,null,null,null],"name":"lib/media_server/accounts/user_notifier.ex","source":"defmodule MediaServer.Accounts.UserNotifier do\n  import Swoosh.Email\n\n  alias MediaServer.Mailer\n\n  # Delivers the email using the application mailer.\n  defp deliver(recipient, subject, body) do\n    email =\n      new()\n      |> to(recipient)\n      |> from({\"MyApp\", \"contact@example.com\"})\n      |> subject(subject)\n      |> text_body(body)\n\n    with {:ok, _metadata} <- Mailer.deliver(email) do\n      {:ok, email}\n    end\n  end\n\n  @doc \"\"\"\n  Deliver instructions to confirm account.\n  \"\"\"\n  def deliver_confirmation_instructions(user, url) do\n    deliver(user.email, \"Confirmation instructions\", \"\"\"\n\n    ==============================\n\n    Hi #{user.email},\n\n    You can confirm your account by visiting the URL below:\n\n    #{url}\n\n    If you didn't create an account with us, please ignore this.\n\n    ==============================\n    \"\"\")\n  end\n\n  def deliver_invitation_instructions(user, password) do\n    deliver(user.email, \"Invitation instructions\", \"\"\"\n\n    ==============================\n\n    Hi #{user.email},\n\n    An account has been created for you.\n\n    You're account details are:\n\n    Email: #{user.email}\n    Password: #{password}\n\n    If you weren't expecting an account with us, please ignore this.\n\n    ==============================\n    \"\"\")\n  end\n\n  @doc \"\"\"\n  Deliver instructions to reset a user password.\n  \"\"\"\n  def deliver_reset_password_instructions(user, url) do\n    deliver(user.email, \"Reset password instructions\", \"\"\"\n\n    ==============================\n\n    Hi #{user.email},\n\n    You can reset your password by visiting the URL below:\n\n    #{url}\n\n    If you didn't request this change, please ignore this.\n\n    ==============================\n    \"\"\")\n  end\n\n  @doc \"\"\"\n  Deliver instructions to update a user email.\n  \"\"\"\n  def deliver_update_email_instructions(user, url) do\n    deliver(user.email, \"Update email instructions\", \"\"\"\n\n    ==============================\n\n    Hi #{user.email},\n\n    You can change your email by visiting the URL below:\n\n    #{url}\n\n    If you didn't request this change, please ignore this.\n\n    ==============================\n    \"\"\")\n  end\nend"},{"coverage":[null,null,null,null],"name":"lib/media_server_web/components/poster_component.ex","source":"defmodule MediaServerWeb.Components.PosterComponent do\n  use MediaServerWeb, :live_component\n\nend"},{"coverage":[null,null,null,null,null,null,1,null,null,null,1,null,null,null,1,1,null,null,null,1,null,0,null,null,null,null,null,1,1,null,null,null,1,null,0,null,null,null,null],"name":"lib/media_server_web/components/integration_component.ex","source":"defmodule MediaServerWeb.Components.IntegrationComponent do\n  use MediaServerWeb, :live_component\n\n  alias MediaServer.Integrations\n\n  def handle_event(\"save\", %{\"radarr\" => radarr_params}, socket) do\n    save_radarr(socket, radarr_params)\n  end\n\n  def handle_event(\"save\", %{\"sonarr\" => sonarr_params}, socket) do\n    save_sonarr(socket, sonarr_params)\n  end\n\n  defp save_radarr(socket, radarr_params) do\n    case Integrations.update_or_create_radarr(radarr_params) do\n      {:ok, _radarr} ->\n        {:noreply,\n          socket\n          |> put_flash(:info, \"Success\")\n          |> push_redirect(to: socket.assigns.return_to)}\n\n      {:error, %Ecto.Changeset{} = changeset} ->\n        {:noreply, assign(socket, :changeset, changeset)}\n    end\n  end\n\n  defp save_sonarr(socket, sonarr_params) do\n    case Integrations.update_or_create_sonarr(sonarr_params) do\n      {:ok, _sonarr} ->\n        {:noreply,\n          socket\n          |> put_flash(:info, \"Success\")\n          |> push_redirect(to: socket.assigns.return_to)}\n\n      {:error, %Ecto.Changeset{} = changeset} ->\n        {:noreply, assign(socket, :changeset, changeset)}\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,null,null,71,71,null,null,null,null,null,null,null,null,null,null,null,null,16,33,10,null,null,null,null],"name":"test/support/data_case.ex","source":"defmodule MediaServer.DataCase do\n  @moduledoc \"\"\"\n  This module defines the setup for tests requiring\n  access to the application's data layer.\n\n  You may define functions here to be used as helpers in\n  your tests.\n\n  Finally, if the test case interacts with the database,\n  we enable the SQL sandbox, so changes done to the database\n  are reverted at the end of every test. If you are using\n  PostgreSQL, you can even run database tests asynchronously\n  by setting `use MediaServer.DataCase, async: true`, although\n  this option is not recommended for other databases.\n  \"\"\"\n\n  use ExUnit.CaseTemplate\n\n  using do\n    quote do\n      alias MediaServer.Repo\n\n      import Ecto\n      import Ecto.Changeset\n      import Ecto.Query\n      import MediaServer.DataCase\n    end\n  end\n\n  setup tags do\n    pid = Ecto.Adapters.SQL.Sandbox.start_owner!(MediaServer.Repo, shared: not tags[:async])\n    on_exit(fn -> Ecto.Adapters.SQL.Sandbox.stop_owner(pid) end)\n    :ok\n  end\n\n  @doc \"\"\"\n  A helper that transforms changeset errors into a map of messages.\n\n      assert {:error, changeset} = Accounts.create_user(%{password: \"short\"})\n      assert \"password is too short\" in errors_on(changeset).password\n      assert %{password: [\"password is too short\"]} = errors_on(changeset)\n\n  \"\"\"\n  def errors_on(changeset) do\n    Ecto.Changeset.traverse_errors(changeset, fn {message, opts} ->\n      Regex.replace(~r\"%{(\\w+)}\", message, fn _, key ->\n        opts |> Keyword.get(String.to_existing_atom(key), key) |> to_string()\n      end)\n    end)\n  end\nend"},{"coverage":[null,null,null,null,1,1,null,null,null,null,null,1,null,null],"name":"lib/media_server_web/live/series_live/index.ex","source":"defmodule MediaServerWeb.SeriesLive.Index do\n  use MediaServerWeb, :live_view\n\n  @impl true\n  def handle_params(params, _url, socket) do\n    {:noreply, apply_action(socket, socket.assigns.live_action, params)}\n  end\n\n  defp apply_action(socket, :index, _params) do\n    socket\n    |> assign(:page_title, :Series)\n    |> assign(:decoded, MediaServerWeb.Repositories.Series.get_all())\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null],"name":"lib/media_server.ex","source":"defmodule MediaServer do\n  @moduledoc \"\"\"\n  MediaServer keeps the contexts that define your domain\n  and business logic.\n\n  Contexts are also responsible for managing your data, regardless\n  if it comes from the database, an external API or others.\n  \"\"\"\nend"},{"coverage":[null,null,null,null,null,null,91,116,null,null,80,null,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,78,null,null,null,null,78,null,null,null,3,null,null,null,null,3,null,null,null,13,13,13,null,null],"name":"test/support/fixtures/accounts_fixtures.ex","source":"defmodule MediaServer.AccountsFixtures do\n  @moduledoc \"\"\"\n  This module defines test helpers for creating\n  entities via the `MediaServer.Accounts` context.\n  \"\"\"\n\n  def unique_user_email, do: \"user#{System.unique_integer()}@example.com\"\n  def valid_user_password, do: \"hello world!\"\n\n  def valid_user_attributes(attrs \\\\ %{}) do\n    Enum.into(attrs, %{\n      email: unique_user_email(),\n      name: \"Some Name\",\n      password: valid_user_password()\n    })\n  end\n\n  def valid_user_admin_attributes(attrs \\\\ %{}) do\n    Enum.into(attrs, %{\n      email: unique_user_email(),\n      name: \"Some Name\",\n      password: valid_user_password(),\n      is_admin: true\n    })\n  end\n\n  def user_fixture(attrs \\\\ %{}) do\n    {:ok, user} =\n      attrs\n      |> valid_user_attributes()\n      |> MediaServer.Accounts.register_user()\n\n    user\n  end\n\n  def user_admin_fixture(attrs \\\\ %{}) do\n    {:ok, user} =\n      attrs\n      |> valid_user_admin_attributes()\n      |> MediaServer.Accounts.register_user()\n\n    user\n  end\n\n  def extract_user_token(fun) do\n    {:ok, captured_email} = fun.(&\"[TOKEN]#{&1}[TOKEN]\")\n    [_, token | _] = String.split(captured_email.text_body, \"[TOKEN]\")\n    token\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,85,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,38,38,null,null,null,null,null,null,null,null,null,null,null,51,51,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,15,null,null,null,15,15,null,null,null,null,null,null,15,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,null,4,4,null,4,4,null,null,null,null,null,null,0,null,null,null,null,2,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,3,null,3,3,null,null,null,null,0,null,null,null,null,null,null,null,null,61,null,null,null,null,null,null,9,null,null,null,2,null,null],"name":"lib/media_server/accounts/user_token.ex","source":"defmodule MediaServer.Accounts.UserToken do\n  use Ecto.Schema\n  import Ecto.Query\n\n  @hash_algorithm :sha256\n  @rand_size 32\n\n  # It is very important to keep the reset password token expiry short,\n  # since someone with access to the email may take over the account.\n  @reset_password_validity_in_days 1\n  @confirm_validity_in_days 7\n  @change_email_validity_in_days 7\n  @session_validity_in_days 60\n\n  schema \"users_tokens\" do\n    field :token, :binary\n    field :context, :string\n    field :sent_to, :string\n    belongs_to :user, MediaServer.Accounts.User\n\n    timestamps(updated_at: false)\n  end\n\n  @doc \"\"\"\n  Generates a token that will be stored in a signed place,\n  such as session or cookie. As they are signed, those\n  tokens do not need to be hashed.\n\n  The reason why we store session tokens in the database, even\n  though Phoenix already provides a session cookie, is because\n  Phoenix' default session cookies are not persisted, they are\n  simply signed and potentially encrypted. This means they are\n  valid indefinitely, unless you change the signing/encryption\n  salt.\n\n  Therefore, storing them allows individual user\n  sessions to be expired. The token system can also be extended\n  to store additional data, such as the device used for logging in.\n  You could then use this information to display all valid sessions\n  and devices in the UI and allow users to explicitly expire any\n  session they deem invalid.\n  \"\"\"\n  def build_session_token(user) do\n    token = :crypto.strong_rand_bytes(@rand_size)\n    {token, %MediaServer.Accounts.UserToken{token: token, context: \"session\", user_id: user.id}}\n  end\n\n  @doc \"\"\"\n  Checks if the token is valid and returns its underlying lookup query.\n\n  The query returns the user found by the token, if any.\n\n  The token is valid if it matches the value in the database and it has\n  not expired (after @session_validity_in_days).\n  \"\"\"\n  def verify_session_token_query(token) do\n    query =\n      from token in token_and_context_query(token, \"session\"),\n        join: user in assoc(token, :user),\n        where: token.inserted_at > ago(@session_validity_in_days, \"day\"),\n        select: user\n\n    {:ok, query}\n  end\n\n  @doc \"\"\"\n  Builds a token and its hash to be delivered to the user's email.\n\n  The non-hashed token is sent to the user email while the\n  hashed part is stored in the database. The original token cannot be reconstructed,\n  which means anyone with read-only access to the database cannot directly use\n  the token in the application to gain access. Furthermore, if the user changes\n  their email in the system, the tokens sent to the previous email are no longer\n  valid.\n\n  Users can easily adapt the existing code to provide other types of delivery methods,\n  for example, by phone numbers.\n  \"\"\"\n  def build_email_token(user, context) do\n    build_hashed_token(user, context, user.email)\n  end\n\n  defp build_hashed_token(user, context, sent_to) do\n    token = :crypto.strong_rand_bytes(@rand_size)\n    hashed_token = :crypto.hash(@hash_algorithm, token)\n\n    {Base.url_encode64(token, padding: false),\n     %MediaServer.Accounts.UserToken{\n       token: hashed_token,\n       context: context,\n       sent_to: sent_to,\n       user_id: user.id\n     }}\n  end\n\n  @doc \"\"\"\n  Checks if the token is valid and returns its underlying lookup query.\n\n  The query returns the user found by the token, if any.\n\n  The given token is valid if it matches its hashed counterpart in the\n  database and the user email has not changed. This function also checks\n  if the token is being used within a certain period, depending on the\n  context. The default contexts supported by this function are either\n  \"confirm\", for account confirmation emails, and \"reset_password\",\n  for resetting the password. For verifying requests to change the email,\n  see `verify_change_email_token_query/2`.\n  \"\"\"\n  def verify_email_token_query(token, context) do\n    case Base.url_decode64(token, padding: false) do\n      {:ok, decoded_token} ->\n        hashed_token = :crypto.hash(@hash_algorithm, decoded_token)\n        days = days_for_context(context)\n\n        query =\n          from token in token_and_context_query(hashed_token, context),\n            join: user in assoc(token, :user),\n            where: token.inserted_at > ago(^days, \"day\") and token.sent_to == user.email,\n            select: user\n\n        {:ok, query}\n\n      :error ->\n        :error\n    end\n  end\n\n  defp days_for_context(\"confirm\"), do: @confirm_validity_in_days\n  defp days_for_context(\"reset_password\"), do: @reset_password_validity_in_days\n\n  @doc \"\"\"\n  Checks if the token is valid and returns its underlying lookup query.\n\n  The query returns the user found by the token, if any.\n\n  This is used to validate requests to change the user\n  email. It is different from `verify_email_token_query/2` precisely because\n  `verify_email_token_query/2` validates the email has not changed, which is\n  the starting point by this function.\n\n  The given token is valid if it matches its hashed counterpart in the\n  database and if it has not expired (after @change_email_validity_in_days).\n  The context must always start with \"change:\".\n  \"\"\"\n  def verify_change_email_token_query(token, \"change:\" <> _ = context) do\n    case Base.url_decode64(token, padding: false) do\n      {:ok, decoded_token} ->\n        hashed_token = :crypto.hash(@hash_algorithm, decoded_token)\n\n        query =\n          from token in token_and_context_query(hashed_token, context),\n            where: token.inserted_at > ago(@change_email_validity_in_days, \"day\")\n\n        {:ok, query}\n\n      :error ->\n        :error\n    end\n  end\n\n  @doc \"\"\"\n  Returns the token struct for the given token value and context.\n  \"\"\"\n  def token_and_context_query(token, context) do\n    from MediaServer.Accounts.UserToken, where: [token: ^token, context: ^context]\n  end\n\n  @doc \"\"\"\n  Gets all tokens for the given user for the given contexts.\n  \"\"\"\n  def user_and_contexts_query(user, :all) do\n    from t in MediaServer.Accounts.UserToken, where: t.user_id == ^user.id\n  end\n\n  def user_and_contexts_query(user, [_ | _] = contexts) do\n    from t in MediaServer.Accounts.UserToken, where: t.user_id == ^user.id and t.context in ^contexts\n  end\nend"},{"coverage":[null,null,null],"name":"lib/media_server_web/views/watch_view.ex","source":"defmodule MediaServerWeb.WatchView do\n  use MediaServerWeb, :view\nend"},{"coverage":[null,null,null,null,2,null,null,null,2,null,null,null,4,null,2,2,null,null,null,null,null,4,null,4,null,null,null,4,4,null,null,null,4,4,null,null],"name":"lib/media_server_web/controllers/stream_controller.ex","source":"defmodule MediaServerWeb.StreamController do\n  use MediaServerWeb, :controller\n  \n  def show(%{req_headers: headers} = conn, %{\"movie\" => movie}) do\n    send_video(conn, headers, MediaServerWeb.Repositories.Movies.get_movie_path(movie))\n  end\n\n  def show(%{req_headers: headers} = conn, %{\"episode\" => episode}) do\n    send_video(conn, headers, MediaServerWeb.Repositories.Series.get_episode_path(episode))\n  end\n\n  defp get_offset(headers) do\n    case List.keyfind(headers, \"range\", 0) do\n      {\"range\", \"bytes=\" <> start_pos} ->\n        String.split(start_pos, \"-\") |> hd |> String.to_integer\n      nil ->\n        0\n    end\n  end\n  \n  defp get_file_size(path) do\n    {:ok, %{size: size}} = File.stat path\n\n    size\n  end\n  \n  defp send_video(conn, headers, path) do\n    offset = get_offset(headers)\n    file_size = get_file_size(path)\n\n    conn\n    |> put_resp_header(\"content-type\", \"video/mp4\")\n    |> put_resp_header(\"content-range\", \"bytes #{offset}-#{file_size-1}/#{file_size}\")\n    |> send_file(206, path, offset, file_size - offset)\n  end\nend"},{"coverage":[null,null,null,null,null,null,1,null,null,null,1,null,1,null,null,null,null,1,null,0,null,null,null,null],"name":"lib/media_server_web/components/user_invitation_component.ex","source":"defmodule MediaServerWeb.Components.UserInvitationComponent do\n  use MediaServerWeb, :live_component\n\n  alias MediaServer.Accounts\n\n  def handle_event(\"save\", %{\"user\" => user_params}, socket) do\n    create(socket, %{\"user\" => %{\"email\" => user_params[\"email\"], \"name\" => user_params[\"name\"], \"password\" => \"#{ Enum.take_random(?a..?z, 12) }\"}})\n  end\n\n  def create(socket, %{\"user\" => user_params}) do\n    case Accounts.register_user(user_params) do\n      {:ok, user} ->\n        Accounts.deliver_user_invitation_instructions(user, user_params[\"password\"])\n        {\n          :noreply,\n          socket\n          |> put_flash(:info, \"Success\")\n          |> push_redirect(to: socket.assigns.return_to)\n        }\n      {:error, %Ecto.Changeset{} = changeset} ->\n        {:noreply, assign(socket, :changeset, changeset)}\n    end\n  end\nend"},{"coverage":[null,null,null,null,51,null,null,null,null,null,null,null,null,null,null,null,44,null,null],"name":"lib/media_server/integrations/sonarr.ex","source":"defmodule MediaServer.Integrations.Sonarr do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"sonarrs\" do\n    field :api_key, :string\n    field :name, :string\n    field :url, :string\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(sonarr, attrs) do\n    sonarr\n    |> cast(attrs, [:name, :url, :api_key])\n    |> validate_required([:name, :url, :api_key])\n  end\nend"},{"coverage":[null,null,null],"name":"lib/media_server/mailer.ex","source":"defmodule MediaServer.Mailer do\n  use Swoosh.Mailer, otp_app: :media_server\nend"},{"coverage":[null,null,null,null,null,null,null,22,null,22,null,0,null,null,null,22,null,null,null,null,null,3,null,0,null,null,3,null,null,null,3,3,3,null,null,null,null,null,null,1,null,null,1,null,1,1,null,null,null,null,null,3,null,null,3,null,null,null,null,null,4,null,null,1140,4,null,null,null,null,null,6,null,null,6,null,null,null,null,null,2,null,null,2,null,2,null,null,null,null,5,5,null,null,null],"name":"lib/media_server_web/repositories/series.ex","source":"defmodule MediaServerWeb.Repositories.Series do\n\n  import Ecto.Query\n  alias MediaServer.Repo\n  alias MediaServer.Integrations.Sonarr\n\n  def get_url(url) do\n    sonarr = Sonarr |> last(:inserted_at) |> Repo.one\n\n    case sonarr do\n\n      nil ->\n        nil\n\n      _ ->\n        \"#{ sonarr.url }/#{ url }?apikey=#{ sonarr.api_key }\"\n    end\n  end\n\n  def get_latest(amount) do\n\n    case get_url(\"series\") do\n\n      nil -> []\n\n      _ ->\n        case HTTPoison.get(get_url(\"series\")) do\n\n          {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->\n\n            Enum.sort_by(Jason.decode!(body), &(&1[\"added\"]), :desc)\n            |> Enum.filter(fn x -> x[\"statistics\"][\"episodeFileCount\"] !== 0 end)\n            |> Enum.take(amount)\n        end\n    end\n  end\n\n  def get_all() do\n\n    case HTTPoison.get(get_url(\"series\")) do\n\n      {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->\n        decoded = Jason.decode!(body)\n\n        Enum.sort_by(decoded, &(&1[\"title\"]), :asc)\n        |> Enum.filter(fn x -> x[\"statistics\"][\"episodeFileCount\"] !== 0 end)\n    end\n  end\n\n  def get_serie(id) do\n\n    case HTTPoison.get(get_url(\"series/#{ id }\")) do\n\n      {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->\n        Jason.decode!(body)\n    end\n  end\n\n  def get_episodes(series_id) do\n\n    case HTTPoison.get(\"#{ get_url(\"episode\") }&seriesId=#{ series_id }\") do\n\n      {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->\n        Enum.filter(Jason.decode!(body), fn x -> x[\"hasFile\"] end)\n        |> add_images_to_episodes()\n    end\n  end\n\n  def get_episode(episode) do\n\n    case HTTPoison.get(\"#{ get_url(\"episode/#{ episode }\") }\") do\n\n      {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->\n        Jason.decode!(body)\n    end\n  end\n\n  def get_episode_path(episode) do\n\n    case HTTPoison.get(\"#{ get_url(\"episode/#{ episode }\") }\") do\n\n      {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->\n        decoded= Jason.decode!(body)\n\n        decoded[\"episodeFile\"][\"path\"]\n    end\n  end\n\n  def add_images_to_episodes(episodes) do\n    Enum.map(episodes, fn episode ->\n      Map.put(episode, \"images\", Map.get(get_episode(episode[\"id\"]), \"images\"))\n    end)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,13,null,13,null,2,null,null,null,11,null,null,null,null,null,4,null,2,null,null,2,null,null,null,2,2,2,null,null,null,null,null,null,1,null,null,1,null,1,1,null,null,null,null,null,4,null,null,4,null,null,null,null,null,2,null,null,2,null,2,null,null,null],"name":"lib/media_server_web/repositories/movies.ex","source":"defmodule MediaServerWeb.Repositories.Movies do\n\n  import Ecto.Query\n  alias MediaServer.Repo\n  alias MediaServer.Integrations.Radarr\n\n  def get_url(url) do\n    radarr = Radarr |> last(:inserted_at) |> Repo.one\n\n    case radarr do\n\n      nil ->\n        nil\n\n      _ ->\n        \"#{ radarr.url }/#{ url }?apiKey=#{ radarr.api_key }\"\n    end\n  end\n\n  def get_latest(amount) do\n\n    case get_url(\"movie\") do\n\n      nil -> []\n\n      _ ->\n        case HTTPoison.get(get_url(\"movie\")) do\n\n          {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->\n\n            Enum.sort_by(Jason.decode!(body), &(&1[\"movieFile\"][\"dateAdded\"]), :desc)\n            |> Enum.filter(fn x -> x[\"hasFile\"] end)\n            |> Enum.take(amount)\n        end\n    end\n  end\n\n  def get_all() do\n\n    case HTTPoison.get(get_url(\"movie\")) do\n\n      {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->\n        decoded = Jason.decode!(body)\n\n        Enum.filter(decoded, fn x -> x[\"hasFile\"] end)\n        |> Enum.sort_by(&(&1[\"title\"]), :asc)\n    end\n  end\n\n  def get_movie(id) do\n\n    case HTTPoison.get(\"#{ get_url(\"movie/#{ id }\") }\") do\n\n      {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->\n        Jason.decode!(body)\n    end\n  end\n\n  def get_movie_path(id) do\n\n    case HTTPoison.get(\"#{ get_url(\"movie/#{ id }\") }\") do\n\n      {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->\n        decoded = Jason.decode!(body)\n\n        decoded[\"movieFile\"][\"path\"]\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,1,null,null,null,null,1,null,null,null,null,null,null,null,1,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null],"name":"lib/media_server_web/telemetry.ex","source":"defmodule MediaServerWeb.Telemetry do\n  use Supervisor\n  import Telemetry.Metrics\n\n  def start_link(arg) do\n    Supervisor.start_link(__MODULE__, arg, name: __MODULE__)\n  end\n\n  @impl true\n  def init(_arg) do\n    children = [\n      # Telemetry poller will execute the given period measurements\n      # every 10_000ms. Learn more here: https://hexdocs.pm/telemetry_metrics\n      {:telemetry_poller, measurements: periodic_measurements(), period: 10_000}\n      # Add reporters as children of your supervision tree.\n      # {Telemetry.Metrics.ConsoleReporter, metrics: metrics()}\n    ]\n\n    Supervisor.init(children, strategy: :one_for_one)\n  end\n\n  def metrics do\n    [\n      # Phoenix Metrics\n      summary(\"phoenix.endpoint.stop.duration\",\n        unit: {:native, :millisecond}\n      ),\n      summary(\"phoenix.router_dispatch.stop.duration\",\n        tags: [:route],\n        unit: {:native, :millisecond}\n      ),\n\n      # Database Metrics\n      summary(\"media_server.repo.query.total_time\",\n        unit: {:native, :millisecond},\n        description: \"The sum of the other measurements\"\n      ),\n      summary(\"media_server.repo.query.decode_time\",\n        unit: {:native, :millisecond},\n        description: \"The time spent decoding the data received from the database\"\n      ),\n      summary(\"media_server.repo.query.query_time\",\n        unit: {:native, :millisecond},\n        description: \"The time spent executing the query\"\n      ),\n      summary(\"media_server.repo.query.queue_time\",\n        unit: {:native, :millisecond},\n        description: \"The time spent waiting for a database connection\"\n      ),\n      summary(\"media_server.repo.query.idle_time\",\n        unit: {:native, :millisecond},\n        description:\n          \"The time the connection spent waiting before being checked out for the query\"\n      ),\n\n      # VM Metrics\n      summary(\"vm.memory.total\", unit: {:byte, :kilobyte}),\n      summary(\"vm.total_run_queue_lengths.total\"),\n      summary(\"vm.total_run_queue_lengths.cpu\"),\n      summary(\"vm.total_run_queue_lengths.io\")\n    ]\n  end\n\n  defp periodic_measurements do\n    [\n      # A module, function and arguments to be invoked periodically.\n      # This function must call :telemetry.execute/3 and a metric must be added above.\n      # {MediaServerWeb, :count_users, []}\n    ]\n  end\nend"},{"coverage":[null,null,null,null,null,null,1,null,null,null,1,1,null,null,null,null,1,null,0,null,null,null,null],"name":"lib/media_server_web/components/user_account_component.ex","source":"defmodule MediaServerWeb.Components.UserAccountComponent do\n  use MediaServerWeb, :live_component\n\n  alias MediaServer.Accounts\n\n  def handle_event(\"save\", %{\"user\" => user_params}, socket) do\n    create(socket, %{\"user\" => %{\"name\" => user_params[\"name\"]}})\n  end\n\n  def create(socket, %{\"user\" => user_params}) do\n    case Accounts.update_user_name(socket.assigns.current_user, user_params) do\n      {:ok, _user} ->\n        {\n          :noreply,\n          socket\n          |> put_flash(:info, \"Success\")\n          |> push_redirect(to: socket.assigns.return_to)\n        }\n      {:error, %Ecto.Changeset{} = changeset} ->\n        {:noreply, assign(socket, :changeset, changeset)}\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,null],"name":"lib/media_server_web/live/live_helpers.ex","source":"defmodule MediaServerWeb.LiveHelpers do\n  import Phoenix.LiveView.Helpers\n\n  @doc \"\"\"\n  Renders a component inside the `MediaServerWeb.ModalComponent` component.\n\n  The rendered modal receives a `:return_to` option to properly update\n  the URL when the modal is closed.\n\n  ## Examples\n\n      <%= live_modal MediaServerWeb.LibraryLive.FormComponent,\n        id: @library.id || :new,\n        action: @live_action,\n        library: @library,\n        return_to: Routes.library_index_path(@socket, :index) %>\n  \"\"\"\n  def live_modal(component, opts) do\n    path = Keyword.fetch!(opts, :return_to)\n    modal_opts = [id: :modal, return_to: path, component: component, opts: opts]\n    live_component(MediaServerWeb.ModalComponent, modal_opts)\n  end\nend"}]}